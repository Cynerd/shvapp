<html>
	<head>
		<title>WebSocket Shv Broker test Client</title>
		<meta charset="utf-8">
	</head>
	<body>
		<h1>WebSocket Shv Broker test Client</h1>
		<p>
			<button onClick="initWebSocket();">Connect</button>
			<button onClick="stopWebSocket();">Disconnect</button>
			<button onClick="checkSocket();">State</button>
		</p>
		<p>
			<input type="text" id="edShvPath" onkeydown="if(event.keyCode==13)sendMessage();"/>
			<input type="text" id="edMethod" onkeydown="if(event.keyCode==13)sendMessage();"/>
			<input type="text" id="edParams" onkeydown="if(event.keyCode==13)sendMessage();"/>
			<button onClick="sendMessage();">Send</button>
		</p>
		<p>
			<textarea id="txtResult" style="width:400px;height:100px;"></textarea>
		</p>
		<p>
			<textarea id="txtLog" style="width:400px;height:200px;"></textarea>
		</p>

		<script type="text/javascript">
			var txtLog = document.getElementById("txtLog");
			function debug(message) {
				txtLog.value += message + "\n";
				txtLog.scrollTop = txtLog.scrollHeight;
			}

			function sendMessage()
			{
				if ( websocket && websocket.readyState == 1 ) {
					var shv_path = document.getElementById("edShvPath").value;
					var method = document.getElementById("edMethod").value;
					var params = document.getElementById("edParams").value;

					callRpcMethod(shv_path, method, params);
				}
			}

			var wsUri = "ws://localhost:3777";
			var websocket = null;
			var hello_phase = false;
			var login_phase = false;
			var broker_connected = false;
			var request_id = 1

			function initWebSocket()
			{
				var txtLog = document.getElementById("txtLog");
				txtLog.value = ""
				request_id = 1;
				try {
					//if (typeof MozWebSocket == 'function')
					//    WebSocket = MozWebSocket;
					if ( websocket && websocket.readyState == 1 )
						websocket.close();
					websocket = new WebSocket( wsUri );
					websocket.binaryType = "arraybuffer";

					websocket.onopen = function (evt) {
						debug("CONNECTED");
						callRpcMethod(null, "hello")
						//sendCpon('<1:1,8:' + request_id++ + ',10:"hello">i{}')
						hello_phase = true;
					};
					websocket.onclose = function (evt) {
						debug("DISCONNECTED");
					};
					websocket.onmessage = function (evt) {
						//console.log( "Message received :", evt.data );
						var cpon = dataToCponRpcMessage(evt.data);
						debug("message received: " + cpon );
						if(hello_phase) {
							// <1:1,8:1>i{2:{"nonce":"1805368699"}}
							var rqid = parseInt(cpon.split(">")[0].split("8:")[1]);
							if(rqid == 1) {
								// <T:RpcMessage,id:2,method:"login">i{params:{"login":{"password":"lub42DUB","type":"PLAIN","user":"iot"},"options":{"device":{"mountPoint":"test/agent1"},"idleWatchDogTimeOut":0}}}
								let params = '{"login":{"password":"lub42DUB","type":"PLAIN","user":"iot"},"options":{"device":{"mountPoint":"test/agent1"},"idleWatchDogTimeOut":0}}'
								callRpcMethod(null, "login", params)
								hello_phase = false;
								login_phase = true;
							}
						}
						else if(login_phase) {
							// <T:RpcMessage,id:2>i{result:{"clientId":2}}
							var rqid = parseInt(cpon.split(">")[0].split("8:")[1]);
							if(rqid == 2) {
								login_phase = false;
								broker_connected = true;
								debug('SUCCESS: connected to shv broker');
							}
						}
						else if(broker_connected) {
							var txtResult = document.getElementById("txtResult");
							// result == 2
							// error == 3
							var ret_key = parseInt(cpon.split(">i{")[1].split(":")[0]);
							if(ret_key == 2) {
								txtResult.value = cpon.split(">i{")[1].slice(2, -1)
								txtResult.style.background = ""
							}
							else if(ret_key == 3) {
								txtResult.value = cpon.split(">i{")[1].slice(2, -1)
								txtResult.style.background = "salmon"
							}
						}
					};
					websocket.onerror = function (evt) {
						debug('ERROR: ' + evt.data);
					};
				} catch (exception) {
					debug('ERROR: ' + exception);
				}
			}

			function stopWebSocket() {
				if (websocket)
					websocket.close();
			}

			function checkSocket() {
				if (websocket != null) {
					var stateStr;
					switch (websocket.readyState) {
						case 0: {
							stateStr = "CONNECTING";
							break;
						}
						case 1: {
							stateStr = "OPEN";
							break;
						}
						case 2: {
							stateStr = "CLOSING";
							break;
						}
						case 3: {
							stateStr = "CLOSED";
							break;
						}
						default: {
							stateStr = "UNKNOW";
							break;
						}
					}
					debug("WebSocket state = " + websocket.readyState + " ( " + stateStr + " )");
				} else {
					debug("WebSocket is null");
				}
			}

			function callRpcMethod(shv_path, method, params)
			{
				// 8 - requestId
				// 9 - shvPath
				// 10 - method
				if(!params)
					params = "null"
				var cpon = '<1:1,8:' + request_id++;
				if(shv_path)
					cpon += ',9:"' + shv_path + '"'
				cpon += ',10:"' + method + '">i{1:' + params + '}'
				sendCpon(cpon);
			}

			function sendCpon(cpon)
			{
				if(websocket && websocket.readyState == 1) {
					var a = strToUtf8Array(cpon);
					const CPON_PROTO = 2
					let dgram_len = a.length + 1;
					if(dgram_len < 128)
						a.unshift(dgram_len, CPON_PROTO);
					else
						a.unshift(128 + (dgram_len >> 8), dgram_len % 256, CPON_PROTO);
					const ba = new Uint8Array(a.length);
					for(let i=0; i<a.length; i++)
						ba[i] = a[i];
					debug("sending " + ba.length + " bytes of data")
					websocket.send(ba)
				}
			}

			function dataToCponRpcMessage(buf)
			{
				return String.fromCharCode.apply(null, new Uint8Array(buf, 2));
			}

			function strToUtf8Array(str) {
				var utf8 = [];
				for (var i=0; i < str.length; i++) {
					var charcode = str.charCodeAt(i);
					if (charcode < 0x80) utf8.push(charcode);
					else if (charcode < 0x800) {
						utf8.push(0xc0 | (charcode >> 6),
								  0x80 | (charcode & 0x3f));
					}
					else if (charcode < 0xd800 || charcode >= 0xe000) {
						utf8.push(0xe0 | (charcode >> 12),
								  0x80 | ((charcode>>6) & 0x3f),
								  0x80 | (charcode & 0x3f));
					}
					// surrogate pair
					else {
						i++;
						charcode = ((charcode&0x3ff)<<10)|(str.charCodeAt(i)&0x3ff)
						utf8.push(0xf0 | (charcode >>18),
								  0x80 | ((charcode>>12) & 0x3f),
								  0x80 | ((charcode>>6) & 0x3f),
								  0x80 | (charcode & 0x3f));
					}
				}
				return utf8;
			}
			function jsArrayToUint8Array(arr)
			{
				const uint8a = new Uint8Array(s.length);
				for(let i=0; i<arr.length; i++)
					uint8a[i] = arr[i];
				return utf8a;
			}
			function strToUtf8Uint8Array(str)
			{
				return jsArrayToUint8Array(strToUtf8Array(str));
			}
		</script>
	</body>
</html>
